breakpoint;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1] * 16) + 9]=-1;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1] * 16) +13] = SP;
SP=[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1] * 16 +11]*512-1;
backup;
multipush(EIP);
if(EC!=0||[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1] * 16) +13]==PTLR*512-1)then //Stack Overflow or Not a page fault
    print "ERROR CAUSE";
    print EC;
    print "STACK POINTER";
    print [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1] * 16) +13];
    print "Terminating";
    print [SYSTEM_STATUS_TABLE+1];
    R1=3;
    R2=[SYSTEM_STATUS_TABLE+1];
    call PROCESS_MANAGER;
    call SCHEDULER;
else if(EPN>3)then      //Page Fault on Code page
    alias blk R0;
    blk=[DISK_MAP_TABLE+[SYSTEM_STATUS_TABLE+1]*10+EPN];
    multipush(R0);
    R1=5;
    R2=blk;
    call MEMORY_MANAGER;
    R1=R0;
    multipop(R0);
    [PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20+EPN*2]=R1;
    [PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20+EPN*2+1]="1100";
else                    //Page Fault on Heap page
    R1=1;
    call MEMORY_MANAGER;
    alias i R1;
    i=PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20+4;
    [i]=R0;
    [i+1]="1110";
    i=i+2;
    multipush(R1);
    R1=1;
    call MEMORY_MANAGER;
    multipop(R1);
    [i]=R0;
    [i+1]="1110";
endif;
endif;
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 9]=0;
multipop(EIP);
restore;
SP=[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
SP=SP+1;
[[PTBR+2*(SP/512)]*512+SP%512]=EIP;
ireturn;